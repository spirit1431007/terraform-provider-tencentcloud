// Code generated by iacg; DO NOT EDIT.
package cvm

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	cvmv20170312 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudImageFromFamily() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudImageFromFamilyRead,
		Schema: map[string]*schema.Schema{
			"image_family": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Image family name.",
			},

			"image": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Information of Image.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"image_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Image ID.",
						},
						"os_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Operating system of the image.",
						},
						"image_type": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Image type.",
						},
						"created_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Creation time of the image.",
						},
						"image_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Image name.",
						},
						"image_description": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Image description.",
						},
						"image_size": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Image size.",
						},
						"architecture": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Image architecture.",
						},
						"image_state": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Image state.",
						},
						"platform": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Source platform of the image.",
						},
						"image_creator": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Image creator.",
						},
						"image_source": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Image source.",
						},
						"sync_percent": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Synchronization percentage.",
						},
						"is_support_cloudinit": {
							Type:        schema.TypeBool,
							Required:    true,
							Description: "Whether the image supports cloud-init.",
						},
						"snapshot_set": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "Information on the snapshots associated with the image.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"snapshot_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Snapshot ID.",
									},
									"disk_usage": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Type of the cloud disk used to create the snapshot. Valid values: YSTEM_DISK: system disk, DATA_DISK: data disk.",
									},
									"disk_size": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Size of the cloud disk used to create the snapshot, unit(GB).",
									},
								},
							},
						},
						"tags": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "The list of tags bound to the image.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Key.",
									},
									"value": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Vaule.",
									},
								},
							},
						},
						"license_type": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Image license type.",
						},
						"image_family": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Image Family.",
						},
						"image_deprecated": {
							Type:        schema.TypeBool,
							Required:    true,
							Description: "If Image Deprecated.",
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudImageFromFamilyRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_image_from_family.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := CvmService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("image_family"); ok {
		paramMap["ImageFamily"] = helper.String(v.(string))
	}

	var respData *cvmv20170312.DescribeImageFromFamilyResponseParams
	err := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeImageFromFamilyByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if err != nil {
		return err
	}

	var imagefamily string
	imageMap := map[string]interface{}{}

	if respData.Image != nil {
		if respData.Image.ImageId != nil {
			imageMap["image_id"] = respData.Image.ImageId
		}

		if respData.Image.OsName != nil {
			imageMap["os_name"] = respData.Image.OsName
		}

		if respData.Image.ImageType != nil {
			imageMap["image_type"] = respData.Image.ImageType
		}

		if respData.Image.CreatedTime != nil {
			imageMap["created_time"] = respData.Image.CreatedTime
		}

		if respData.Image.ImageName != nil {
			imageMap["image_name"] = respData.Image.ImageName
		}

		if respData.Image.ImageDescription != nil {
			imageMap["image_description"] = respData.Image.ImageDescription
		}

		if respData.Image.ImageSize != nil {
			imageMap["image_size"] = respData.Image.ImageSize
		}

		if respData.Image.Architecture != nil {
			imageMap["architecture"] = respData.Image.Architecture
		}

		if respData.Image.ImageState != nil {
			imageMap["image_state"] = respData.Image.ImageState
		}

		if respData.Image.Platform != nil {
			imageMap["platform"] = respData.Image.Platform
		}

		if respData.Image.ImageCreator != nil {
			imageMap["image_creator"] = respData.Image.ImageCreator
		}

		if respData.Image.ImageSource != nil {
			imageMap["image_source"] = respData.Image.ImageSource
		}

		if respData.Image.SyncPercent != nil {
			imageMap["sync_percent"] = respData.Image.SyncPercent
		}

		if respData.Image.IsSupportCloudinit != nil {
			imageMap["is_support_cloudinit"] = respData.Image.IsSupportCloudinit
		}

		snapshotSetList := make([]map[string]interface{}, 0, len(respData.Image.SnapshotSet))
		if respData.Image.SnapshotSet != nil {
			for _, snapshotSet := range respData.Image.SnapshotSet {
				snapshotSetMap := map[string]interface{}{}

				if snapshotSet.SnapshotId != nil {
					snapshotSetMap["snapshot_id"] = snapshotSet.SnapshotId
				}

				if snapshotSet.DiskUsage != nil {
					snapshotSetMap["disk_usage"] = snapshotSet.DiskUsage
				}

				if snapshotSet.DiskSize != nil {
					snapshotSetMap["disk_size"] = snapshotSet.DiskSize
				}

				snapshotSetList = append(snapshotSetList, snapshotSetMap)
			}

			imageMap["snapshot_set"] = snapshotSetList
		}
		tagsList := make([]map[string]interface{}, 0, len(respData.Image.Tags))
		if respData.Image.Tags != nil {
			for _, tags := range respData.Image.Tags {
				tagsMap := map[string]interface{}{}

				if tags.Key != nil {
					tagsMap["key"] = tags.Key
				}

				if tags.Value != nil {
					tagsMap["value"] = tags.Value
				}

				tagsList = append(tagsList, tagsMap)
			}

			imageMap["tags"] = tagsList
		}
		if respData.Image.LicenseType != nil {
			imageMap["license_type"] = respData.Image.LicenseType
		}

		if respData.Image.ImageFamily != nil {
			imagefamily = *respData.Image.ImageFamily
			imageMap["image_family"] = respData.Image.ImageFamily
		}

		if respData.Image.ImageDeprecated != nil {
			imageMap["image_deprecated"] = respData.Image.ImageDeprecated
		}

		_ = d.Set("image", []interface{}{imageMap})
	}

	d.SetId(imagefamily)

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), imageMap); e != nil {
			return e
		}
	}

	return nil
}
