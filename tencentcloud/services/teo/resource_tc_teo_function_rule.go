// Code generated by iacg; DO NOT EDIT.
package teo

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	teov20220901 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/teo/v20220901"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudTeoFunctionRule() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudTeoFunctionRuleCreate,
		Read:   resourceTencentCloudTeoFunctionRuleRead,
		Update: resourceTencentCloudTeoFunctionRuleUpdate,
		Delete: resourceTencentCloudTeoFunctionRuleDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"zone_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "ID of the site.",
			},

			"rule_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "ID of the Function Rule.",
			},

			"function_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "ID of the Function.",
			},

			"remark": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Rule description, maximum support of 60 characters.",
			},

			"function_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The name of the function.",
			},

			"priority": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "The priority of the function trigger rule. A higher numerical value indicates a higher priority.",
			},

			"function_rule_conditions": {
				Type:        schema.TypeList,
				Required:    true,
				Description: "The list of rule conditions, where the conditions are connected by an \"OR\" relationship.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"rule_conditions": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "For edge function trigger rule conditions, if all items in the list are satisfied, then the condition is considered fulfilled.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"operator": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Operator. Valid values:\n  - `equals`: Equals.\n  - `notEquals`: Does not equal.\n  - `exist`: Exists.\n  - `notexist`: Does not exist.",
									},
									"target": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The match type. Values:\n  - `filename`: File name.\n  - `extension`: File extension.\n  - `host`: Host.\n  - `full_url`: Full URL, which indicates the complete URL path under the current site and must contain the HTTP protocol, host, and path.\n  - `url`: Partial URL under the current site.\n  - `client_country`: Country/Region of the client.\n  - `query_string`: Query string in the request URL.\n  - `request_header`: HTTP request header.",
									},
									"values": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "The parameter value of the match type. It can be an empty string only when `Target=query string/request header` and `Operator=exist/notexist`.\n  - When `Target=extension`, enter the file extension, such as \"jpg\" and \"txt\".\n  - When `Target=filename`, enter the file name, such as \"foo\" in \"foo.jpg\".\n  - When `Target=all`, it indicates any site request.\n  - When `Target=host`, enter the host under the current site, such as \"www.maxx55.com\".\n  - When `Target=url`, enter the partial URL path under the current site, such as \"/example\".\n  - When `Target=full_url`, enter the complete URL under the current site. It must contain the HTTP protocol, host, and path, such as \"https://www.maxx55.cn/example\".\n  - When `Target=client_country`, enter the ISO-3166 country/region code.\n  - When `Target=query_string`, enter the value of the query string, such as \"cn\" and \"1\" in \"lang=cn&version=1\".\n  - When `Target=request_header`, enter the HTTP request header value, such as \"zh-CN,zh;q=0.9\" in the \"Accept-Language:zh-CN,zh;q=0.9\" header.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"ignore_case": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether the parameter value is case insensitive. Default value: false.",
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The parameter name of the match type. This field is required only when `Target=query_string/request_header`.\n  - `query_string`: Name of the query string, such as \"lang\" and \"version\" in \"lang=cn&version=1\".\n  - `request_header`: Name of the HTTP request header, such as \"Accept-Language\" in the \"Accept-Language:zh-CN,zh;q=0.9\" header.",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func resourceTencentCloudTeoFunctionRuleCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_function_rule.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		zoneId     string
		functionId string
		ruleId     string
	)
	var (
		request  = teov20220901.NewCreateFunctionRuleRequest()
		response = teov20220901.NewCreateFunctionRuleResponse()
	)

	if v, ok := d.GetOk("zone_id"); ok {
		zoneId = v.(string)
	}
	if v, ok := d.GetOk("function_id"); ok {
		functionId = v.(string)
	}

	request.ZoneId = helper.String(zoneId)

	if v, ok := d.GetOk("function_rule_conditions"); ok {
		for _, item := range v.([]interface{}) {
			functionRuleConditionsMap := item.(map[string]interface{})
			functionRuleCondition := teov20220901.FunctionRuleCondition{}
			if v, ok := functionRuleConditionsMap["rule_conditions"]; ok {
				for _, item := range v.([]interface{}) {
					ruleConditionsMap := item.(map[string]interface{})
					ruleCondition := teov20220901.RuleCondition{}
					if v, ok := ruleConditionsMap["operator"]; ok {
						ruleCondition.Operator = helper.String(v.(string))
					}
					if v, ok := ruleConditionsMap["target"]; ok {
						ruleCondition.Target = helper.String(v.(string))
					}
					if v, ok := ruleConditionsMap["values"]; ok {
						valuesSet := v.(*schema.Set).List()
						for i := range valuesSet {
							values := valuesSet[i].(string)
							ruleCondition.Values = append(ruleCondition.Values, helper.String(values))
						}
					}
					if v, ok := ruleConditionsMap["ignore_case"]; ok {
						ruleCondition.IgnoreCase = helper.Bool(v.(bool))
					}
					if v, ok := ruleConditionsMap["name"]; ok {
						ruleCondition.Name = helper.String(v.(string))
					}
					functionRuleCondition.RuleConditions = append(functionRuleCondition.RuleConditions, &ruleCondition)
				}
			}
			request.FunctionRuleConditions = append(request.FunctionRuleConditions, &functionRuleCondition)
		}
	}

	request.FunctionId = helper.String(functionId)

	if v, ok := d.GetOk("remark"); ok {
		request.Remark = helper.String(v.(string))
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoV20220901Client().CreateFunctionRuleWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s create teo function rule failed, reason:%+v", logId, err)
		return err
	}

	ruleId = *response.Response.RuleId

	d.SetId(strings.Join([]string{zoneId, functionId, ruleId}, tccommon.FILED_SP))

	return resourceTencentCloudTeoFunctionRuleRead(d, meta)
}

func resourceTencentCloudTeoFunctionRuleRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_function_rule.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := TeoService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 3 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	functionId := idSplit[1]
	ruleId := idSplit[2]

	_ = d.Set("zone_id", zoneId)

	_ = d.Set("function_id", functionId)

	respData, err := service.DescribeTeoFunctionRuleById(ctx, zoneId, functionId, ruleId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `teo_function_rule` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	if respData.RuleId != nil {
		_ = d.Set("rule_id", respData.RuleId)
		ruleId = *respData.RuleId
	}

	if respData.FunctionId != nil {
		_ = d.Set("function_id", respData.FunctionId)
	}

	if respData.FunctionName != nil {
		_ = d.Set("function_name", respData.FunctionName)
	}

	if respData.Remark != nil {
		_ = d.Set("remark", respData.Remark)
	}

	if respData.Priority != nil {
		_ = d.Set("priority", respData.Priority)
	}

	functionRuleConditionsList := make([]map[string]interface{}, 0, len(respData.FunctionRuleConditions))
	if respData.FunctionRuleConditions != nil {
		for _, functionRuleConditions := range respData.FunctionRuleConditions {
			functionRuleConditionsMap := map[string]interface{}{}

			ruleConditionsList := make([]map[string]interface{}, 0, len(functionRuleConditions.RuleConditions))
			if functionRuleConditions.RuleConditions != nil {
				for _, ruleConditions := range functionRuleConditions.RuleConditions {
					ruleConditionsMap := map[string]interface{}{}

					if ruleConditions.Operator != nil {
						ruleConditionsMap["operator"] = ruleConditions.Operator
					}

					if ruleConditions.Target != nil {
						ruleConditionsMap["target"] = ruleConditions.Target
					}

					if ruleConditions.Values != nil {
						ruleConditionsMap["values"] = ruleConditions.Values
					}

					if ruleConditions.IgnoreCase != nil {
						ruleConditionsMap["ignore_case"] = ruleConditions.IgnoreCase
					}

					if ruleConditions.Name != nil {
						ruleConditionsMap["name"] = ruleConditions.Name
					}

					ruleConditionsList = append(ruleConditionsList, ruleConditionsMap)
				}

				functionRuleConditionsMap["rule_conditions"] = ruleConditionsList
			}
			functionRuleConditionsList = append(functionRuleConditionsList, functionRuleConditionsMap)
		}

		_ = d.Set("function_rule_conditions", functionRuleConditionsList)
	}

	return nil
}

func resourceTencentCloudTeoFunctionRuleUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_function_rule.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 3 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	functionId := idSplit[1]
	ruleId := idSplit[2]

	needChange := false
	mutableArgs := []string{"function_rule_conditions", "remark"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := teov20220901.NewModifyFunctionRuleRequest()

		request.ZoneId = helper.String(zoneId)

		request.RuleId = helper.String(ruleId)

		if v, ok := d.GetOk("function_rule_conditions"); ok {
			for _, item := range v.([]interface{}) {
				functionRuleConditionsMap := item.(map[string]interface{})
				functionRuleCondition := teov20220901.FunctionRuleCondition{}
				if v, ok := functionRuleConditionsMap["rule_conditions"]; ok {
					for _, item := range v.([]interface{}) {
						ruleConditionsMap := item.(map[string]interface{})
						ruleCondition := teov20220901.RuleCondition{}
						if v, ok := ruleConditionsMap["operator"]; ok {
							ruleCondition.Operator = helper.String(v.(string))
						}
						if v, ok := ruleConditionsMap["target"]; ok {
							ruleCondition.Target = helper.String(v.(string))
						}
						if v, ok := ruleConditionsMap["values"]; ok {
							valuesSet := v.(*schema.Set).List()
							for i := range valuesSet {
								values := valuesSet[i].(string)
								ruleCondition.Values = append(ruleCondition.Values, helper.String(values))
							}
						}
						if v, ok := ruleConditionsMap["ignore_case"]; ok {
							ruleCondition.IgnoreCase = helper.Bool(v.(bool))
						}
						if v, ok := ruleConditionsMap["name"]; ok {
							ruleCondition.Name = helper.String(v.(string))
						}
						functionRuleCondition.RuleConditions = append(functionRuleCondition.RuleConditions, &ruleCondition)
					}
				}
				request.FunctionRuleConditions = append(request.FunctionRuleConditions, &functionRuleCondition)
			}
		}

		request.FunctionId = helper.String(functionId)

		if v, ok := d.GetOk("remark"); ok {
			request.Remark = helper.String(v.(string))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoV20220901Client().ModifyFunctionRuleWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update teo function rule failed, reason:%+v", logId, err)
			return err
		}
	}

	return resourceTencentCloudTeoFunctionRuleRead(d, meta)
}

func resourceTencentCloudTeoFunctionRuleDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_function_rule.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 3 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	functionId := idSplit[1]
	ruleId := idSplit[2]

	var (
		request  = teov20220901.NewDeleteFunctionRulesRequest()
		response = teov20220901.NewDeleteFunctionRulesResponse()
	)

	request.ZoneId = helper.String(zoneId)

	request.RuleIds = []*string{helper.String(ruleId)}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoV20220901Client().DeleteFunctionRulesWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s delete teo function rule failed, reason:%+v", logId, err)
		return err
	}

	_ = response
	_ = functionId
	return nil
}
